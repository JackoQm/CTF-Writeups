## 答案
其实本题思路已经很清晰了, 我把它稍微总结如下:
1. 在执行程序的时候, 同时获得当前系统时间戳 ;
2. 用获得的时间戳作为随机数的种子, 以生成和程序一致的随机数;
3. 生成八个随机数并按照 myhash 中的计算方式计算出一个没有包含 canary 的总值;
4. 用程序提供的验证码来减去我们计算的值获得 canary (负数需要被正确转换, 具体看脚本)
5. 然后就可以进行栈溢出注入(只需在注入时把 canary 放到正确的位置 $ebp-0xc) 

这里之后的做法就有很多了, 毕竟本题难点仅仅是如何泄漏 canary 值

1. 我自己破解的时候是再跳转到 call system 前,重新执行一边 process_hash 函数, 以重新输入 /bin/sh 到 g_buf 后再跳转, 这样就可以给 system 函数传入 g_buf 的开头地址了(但这样做好像进入 sh 后只能执行一条指令就会退出了);
2. 直接把 /bin/sh 字符串放到输入数据的尾部, 计算出 g_buf 偏移后的地址, 把它传给 system 函数

## PS
我提供了两个版本的 Payload, 第一个是我当初直接用来破解的, 需要和 calc_canary 这个 c 程序进行配合, 但我没有进行整理和注释. 带有 v2 字样的是我后来进行优化, 利用 python 的 ctype 库从而无须多写一个 c 程序, 并且有不错的运行提示, 如果你要参考可以尽量参考后者这个. 每个 Payload 使用的破解手法对应于我之前写的那两点.
